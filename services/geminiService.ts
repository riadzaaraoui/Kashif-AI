import { GoogleGenAI, Type, Modality } from "@google/genai";
import { ImageAspectRatio } from "../types";

// Helper to ensure we get a fresh client, primarily for Veo key selection updates
const getAiClient = () => new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Retry helper for handling 429 Resource Exhausted errors with exponential backoff.
 */
async function callWithRetry<T>(fn: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {
  try {
    return await fn();
  } catch (error: any) {
    if (retries > 0 && (error?.status === 429 || error?.code === 429 || error?.message?.includes('429'))) {
      console.warn(`Quota hit. Retrying in ${delay}ms... (${retries} retries left)`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return callWithRetry(fn, retries - 1, delay * 2);
    }
    throw error;
  }
}

/**
 * Detects if Arabic text is AI generated.
 * Switched to gemini-2.5-flash for better quota management.
 */
export const detectArabicText = async (text: string) => {
  return callWithRetry(async () => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: text,
      config: {
        systemInstruction: `
          You are an expert linguistic analyst specializing in the Arabic language.
          Your task is to analyze the provided Arabic text and determine if it was likely generated by an AI or written by a human.
          
          Analyze for:
          1. Repetitive sentence structures (common in AI).
          2. Unnatural flow or lack of specific cultural nuance.
          3. Perfect but soulless grammar vs human stylistic errors or dialect usage.
          
          Return the result in JSON format:
          {
            "is_ai_generated": boolean,
            "confidence_score": number (0-100),
            "reasoning_ar": "Explanation in Arabic",
            "reasoning_en": "Explanation in English",
            "detected_dialect": "Modern Standard Arabic (MSA), Egyptian, Levantine, etc."
          }
        `,
        responseMimeType: "application/json",
      }
    });
    return response.text ? JSON.parse(response.text) : null;
  });
};

/**
 * Humanizes text to sound more natural and authentic, while expanding it.
 * Switched to gemini-2.5-flash for better quota management.
 */
export const humanizeText = async (text: string) => {
  return callWithRetry(async () => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: text,
      config: {
        systemInstruction: `
          You are an expert creative writer and editor. Your task is to rewrite the provided text (likely Arabic) to make it sound 100% human, authentic, and engaging, while EXPANDING the content.
          
          CRITICAL RULES:
          1. **EXPAND & ELABORATE**: Do NOT summarize. Your goal is to make the text longer and richer. Add relevant details, adjectives, and depth to every point.
          2. **Humanize**: Remove robotic patterns and repetitive structures. Use rich vocabulary and natural flow.
          3. **Style**: Infuse idiomatic expressions and cultural nuances suitable for the context.
          4. **Structure**: Vary sentence length to mimic human thought patterns. Use descriptive language to paint a clearer picture.
          5. If the input is standard MSA (Modern Standard Arabic), add a touch of warmth or specific dialect if it fits the context.
          
          The final output MUST be longer and more detailed than the original text.
          Return ONLY the rewritten text. Do not add explanations.
        `
      }
    });
    return response.text;
  });
};

/**
 * Fast Chat / Search Grounding
 * Uses gemini-2.5-flash
 */
export const searchWithGrounding = async (query: string) => {
  return callWithRetry(async () => {
    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: query,
      config: {
        tools: [{ googleSearch: {} }]
      }
    });
    
    return {
      text: response.text,
      sources: response.candidates?.[0]?.groundingMetadata?.groundingChunks
        ?.map((chunk: any) => chunk.web)
        .filter((w: any) => w) || []
    };
  });
};

/**
 * Generate Image
 * Uses gemini-3-pro-image-preview
 */
export const generateImage = async (prompt: string, aspectRatio: ImageAspectRatio) => {
  return callWithRetry(async () => {
    // Ensure user has selected a key for paid features if needed, though usually handled by UI flow
    const ai = getAiClient();
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-image-preview',
      contents: prompt,
      config: {
        imageConfig: {
          aspectRatio: aspectRatio,
          imageSize: "1K" // Defaulting to 1K for speed/compatibility
        }
      }
    });

    const images: string[] = [];
    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          images.push(`data:image/png;base64,${part.inlineData.data}`);
        }
      }
    }
    return images;
  });
};

/**
 * Edit Image (Nano Banana)
 * Uses gemini-2.5-flash-image
 */
export const editImage = async (base64Image: string, prompt: string) => {
  return callWithRetry(async () => {
    const ai = getAiClient();
    // Remove data URL header if present
    const cleanBase64 = base64Image.split(',')[1] || base64Image;
    
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: 'image/png' // Assuming PNG input/conversion
            }
          },
          { text: prompt }
        ]
      }
    });

    const images: string[] = [];
    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
         if (part.inlineData) {
          images.push(`data:image/png;base64,${part.inlineData.data}`);
        }
      }
    }
    return images;
  });
};

/**
 * Analyze Image
 * Switched to gemini-2.5-flash for better quota management.
 */
export const analyzeImage = async (base64Image: string, prompt: string = "Analyze this image in detail.") => {
  return callWithRetry(async () => {
    const ai = getAiClient();
    const cleanBase64 = base64Image.split(',')[1] || base64Image;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanBase64,
              mimeType: 'image/jpeg' 
            }
          },
          { text: prompt }
        ]
      }
    });
    return response.text;
  });
};

/**
 * Generate Video (Veo)
 * Uses veo-3.1-fast-generate-preview
 */
export const generateVeoVideo = async (prompt: string | null, imageBase64: string | null, aspectRatio: '16:9' | '9:16') => {
  // Veo operations are long-running and typically use a specific paid quota, 
  // but we can still wrap the initial request in retry.
  return callWithRetry(async () => {
    const ai = getAiClient();
    
    // Construct payload
    const imagePart = imageBase64 ? {
      imageBytes: imageBase64.split(',')[1],
      mimeType: 'image/png'
    } : undefined;

    let operation = await ai.models.generateVideos({
      model: 'veo-3.1-fast-generate-preview',
      prompt: prompt || undefined, 
      image: imagePart,
      config: {
        numberOfVideos: 1,
        resolution: '720p',
        aspectRatio: aspectRatio
      }
    });

    // Poll for completion
    while (!operation.done) {
      await new Promise(resolve => setTimeout(resolve, 5000));
      operation = await ai.operations.getVideosOperation({ operation: operation });
    }

    const videoUri = operation.response?.generatedVideos?.[0]?.video?.uri;
    if (!videoUri) throw new Error("Video generation failed");
    
    // Fetch the actual blob
    const res = await fetch(`${videoUri}&key=${process.env.API_KEY}`);
    const blob = await res.blob();
    return URL.createObjectURL(blob);
  });
};
